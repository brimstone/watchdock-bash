#!/bin/bash

set -ueo pipefail

ETCDHOST=localhost
ETCDPORT=4001
TTL=120
ETCDCTLBIN="$(which etcdctl || :)"

DOPULL=0

usage(){
	cat <<DOG
Usage: $0 [--etcdhost hostname] [--etcdport number] [--ttl seconds]
	--etcdhost	hostname for etcd, default: localhost
	--etcdport	port for etcd, default: 4001
	--ttl		TTL for keys, default 120 seconds
	--etcdctl	alternative path for etcdctl binary if not in \$PATH
DOG
}

# This determines if we can even run a container on our host
canrun(){
	# Get locations this container can run, required
	WHERE=""
	WHERE=$($ETCDCTL get $1/where) || continue

	# Determine if we should be running this image
	if [ "$WHERE" = "$HOSTNAME" ]; then
		return 0
	elif [ "$WHERE" = "*" ]; then
		return 0
	else
		for host in $WHERE; do
			if [ "$host" = "$HOSTNAME" ]; then
				return 0
			fi
		done
	fi
	return 1
}

while [ $# -gt 0 ]; do
	case "$1" in
		--debug)
			set -x
		;;
		--etcdhost)
			shift
			ETCDHOST="$1"
		;;
		--etcdport)
			shift
			ETCDPORT="$1"
		;;
		--ttl)
			shift
			TTL="$1"
		;;
		--etcdctl)
			shift
			ETCDCTLBIN="$1"
		;;
		--help)
			shift
			usage
			exit
		;;
		--pull)
			DOPULL=1
		;;
	# TODO force option
		*)
			echo "Unknown option $1"
			exit 1
		;;
	esac
	shift
done

# check to see if 'docker' is already running somewhere else and bail unless forced
DOCKERDPID=$(pgrep -f "docker -d" || pgrep -f "docker.io -d" || :)
if [ -z "$DOCKERDPID" ]; then
	echo "docker -d not detected. Exiting" >&2
	exit 1
fi

OTHERDOCKERPID=$(pgrep docker | grep -v $DOCKERDPID || :)
if [ -n "$OTHERDOCKERPID" ]; then
	echo "Exiting because docker is already running: $( echo "$OTHERDOCKERPID" | tr '\n' ' ')" >&2
	exit 1
fi

if [ -z "$ETCDCTLBIN" ]; then
	echo "Unable to find etcdctl binary, this must be in \$PATH or specified with --etcdctl!" >&2
	exit 1
fi

ETCDCTL="$ETCDCTLBIN -C http://$ETCDHOST:$ETCDPORT"

echo "Checking containers"
containers=""
if ! containers=$($ETCDCTL ls /containers); then
	echo "Error getting containers: $containers. Tried:" >&2
	echo "$ $ETCDCTL ls /containers" >&2
	echo "Maybe you need --etcdhost or --etcdport?" >&2
	exit 1
fi

if [ "$DOPULL" = 1 ]; then
	for container in $containers; do
		# if we can run this container
		if canrun $container; then
			IMAGE=""
			IMAGE=$($ETCDCTL get $container/image) || continue
			# pull down it's image incase we need it later
			docker pull "$IMAGE"
		fi
	done
fi

for container in $containers; do
	NAME="${container##*/}"

	# Get locations this container can run, required
	WHERE=""
	WHERE=$($ETCDCTL get $container/where) || continue

	# Determine if we should be running this image
	SHOULDRUN="false"
	canrun "$container" && SHOULDRUN="true"

	# Check to see if we've hit our max instances 
	MAXINST=""
	if ! MAXINST=$($ETCDCTL get $container/maxinstances); then
		MAXINST=""
	else
		# find our hosts running our container already
		nodes=""
		if ! nodes="$($ETCDCTL ls $container/hosts)"; then
			echo "Why can't I find $container/hosts?" >&2
			exit 1
		fi
		# count up the running instances
		instances=0
		for node in $($ETCDCTL ls $container/hosts); do
			STATE=""
			if ! STATE=$($ETCDCTL get $node); then
				echo "Couldn't read state of host $node" >&2
				continue
			fi
			if [ "$STATE" = "Running" ]; then
				instances=$[ $instances + 1 ]
			fi
		done
		# If we have more than our max, we shouldn't run it
		# FIXME There might be a bug here if we're already running a container \
		#	and there's MAXINST+1 instances running. Not sure how to fix that  \
		#	right now
		if [ "$instances" -gt "$MAXINST" ]; then
			SHOULDRUN="false"
		fi
	fi

	# Determine status of container
	STATUS=""
	if RUNNING=$(docker inspect -f "{{ .State.Running }}" $NAME 2>/dev/null); then
		if [ $RUNNING = "true" ]; then
			STATUS="running"
			$ETCDCTL set --ttl $TTL $container/hosts/$HOSTNAME $STATUS >/dev/null
		else
			STATUS="stopped"
		fi
	fi

	# if we shouldn't be running our image
	if [ "$SHOULDRUN" = "false" ]; then
		# stop it if it's running
		if [ "$STATUS" = "running" ]; then
			echo "$NAME shouldn't be running, stopping"
			docker stop $NAME >/dev/null
			$ETCDCTL set --ttl $TTL $container/hosts/$HOSTNAME stopped >/dev/null
			continue
		else
			echo "$NAME isn't meant for us, ignoring"
			continue
		fi
	# If we should be running
	else
		# And we are
		if [ "$STATUS" = "running" ]; then
			echo "$NAME is running. All is well"
			continue
		# if it's just stopped, start it
		elif [ "$STATUS" = "stopped" ]; then
			docker start "$NAME" >/dev/null
			$ETCDCTL set --ttl $TTL $container/hosts/$HOSTNAME stopped >/dev/null
		# else, gather up what else we need and start it at the bottom
		fi
	fi

	# Get our image, required
	IMAGE=""
	IMAGE=$($ETCDCTL get $container/image) || continue


	# Get our ports, optional
	PORTS=""
	if PORTS=$($ETCDCTL get $container/ports); then
		PORTS=${PORTS// / -p }
		PORTS="-p $PORTS"
	else
		PORTS=""
	fi

	# Get our hostname, optional
	HNAME=""
	if HNAME=$($ETCDCTL get $container/hostname); then
		HNAME="-h $HNAME"
	else
		HNAME=""
	fi

	# Get our volumes, optional
	VOLUMES=""
	if VOLUMES=$($ETCDCTL get $container/volumes); then
		VOLUMES=${VOLUMES// / -v }
		VOLUMES="-v $VOLUMES"
	else
		VOLUMES=""
	fi

	# Get our links, optional
	LINKS=""
	if LINKS=$($ETCDCTL get $container/links); then
		LINKS=${LINKS// / -link }
		LINKS="--link $LINKS"
	else
		LINKS=""
	fi

	# Get our command, optional
	COMMAND=""
	if ! COMMAND=$($ETCDCTL get $container/command); then
		COMMAND=""
	fi

	# Get our pty, optional
	NEEDPTY=""
	if NEEDPTY=$($ETCDCTL get $container/pty); then
		NEEDPTY="-t"
	else
		NEEDPTY=""
	fi

	
	$ETCDCTL set $container/hosts/$HOSTNAME "starting" >/dev/null
	echo docker run -d --name $NAME $NEEDPTY $LINKS $VOLUMES $HNAME $PORTS $IMAGE $COMMAND
	docker run -d --name $NAME $NEEDPTY $LINKS $VOLUMES $HNAME $PORTS $IMAGE $COMMAND
	echo
done
